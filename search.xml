<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>面经 | 腾讯春季校招前端实习生面试经历 | 感觉凉了</title>
      <link href="/2018/04/11/TencentView/"/>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>4月5日参加的腾讯的前端实习生的笔试，当时因为其他的事情，导致准备不充分，做得不是很好，所以做完笔试感觉已经凉了。加之后面学院科创室办比赛的事情以及个人评选十佳优秀团员的事情，就忙得已经淡淡忘了这件事了，也就没有去准备面试了。</p><p>4月10日，这两天一直在忙着整理十佳团员的资料，写个人简介，个人事迹，做宣讲PPT等，今天下午约好了学院新闻中心得帮我拍30秒的宣讲视频。所以一下午都在准备拍视频以及拍视频。下午4点过拍完了，回到工作室继续准备材料，做PPT，突然收到一封邮件，来自于腾讯校招。打开一看，自己都惊了，叫我第二天就去成都某酒店面试。一阵窃喜，但也很忧伤，这么久一直都没有准备面试，没有准备好。现在就很纠结明天到底去不去了，经过朋友、同学、家人的鼓励下，还是选择了去参加面试，就当去体验一次真正的面试（PS：之前从来没有参加过公司面试，腾讯是我第一次面试的公司）。好吧，放下手里的一切事情吧。在食堂吃了晚饭，就开始刷题复习了。</p><p>刷了两三个小时，晚上回寝室了，再看了一会儿，本来想多看一会儿，因为学校11点半会停电，然后就洗了个澡就上床睡觉了。但是在睡觉之前，做了一件事，那就是设了一个闹钟，7点钟，明天早上早点起来刷题吧。</p><p>第二天来到工作室，还没有两个人呢，就开始刷题吧，网上找的一些前端面试题和一些面经。想了想，可能看不完了，去找班主任请个假吧，下午一二节课就不去上课了，好好刷题吧（PS：上午三四节课在教室里面用手机刷，发现好像效果不大。）下午一二节同学都去上课了，我就留在工作室刷题，越刷越紧张，因为重来没有参加过公司面试。好吧，下午4点钟，坐地铁出发吧，去面试的酒店。原计划在地铁上再刷题，但是发现越到面试越浪。就像小时候一样，小考小耍，大考大耍。哎，在地铁上一个题也没看，就拿着自己的彩印的简历，刷刷新闻吧。一个小时左右，到了某酒店。到了指定的位置，发现早早就有人到了面试了，我打开邮件再看，写的是 请带好简历于4月11日18:00前往某酒店参加面试，我一直以为是18：00开始面试，原来这一整天都在面试。用微信扫完码签到完成，就慢慢等着面试吧。等了接近一个小时，广播和手机短信和微信终于通知我到某个房间去面试了。</p><h3 id="正式开始"><a href="#正式开始" class="headerlink" title="正式开始"></a>正式开始</h3><p>第一次参加面试，还是大厂面试，虽然感觉已经凉了。全程大概40分钟左右，在一个五星级酒店的一个房间里，一对一的面试，面试官看起来还不错。<br>一进去面试官问我大学在哪个位置？然后就他到他们招的是腾讯云服务的前端开发，刚好我大一的时候到现在一直在用腾讯云服务器。之后看了一下我的简历，算是正式开始了吧。</p><ul><li>自我介绍，大概讲了一下自己的经历以及做过的项目和编写的书。（大一到现在的经历，大概用了7、8分钟）</li><li>你从做过的事（学长课堂：老生带新生）中最大的收获是什么？（分享中学习，学习中分享）</li><li>说了自己的项目，采用前后端分离做的，为什么逻辑业务都在前端做？（因为更熟悉js，虽然Node也是用js写）</li><li>如何解决跨域问题？（自己用过的是jsonp，其他的不是很了解）</li><li>对http有什么了解？（说了说常见的状态码和TCP的三次握手，以及和UDP的区别）</li><li>vue为什么要使用虚拟DOM？（想必js操作DOMM更能够优化性能，减少资源的请求）</li><li>为什么js操作DOM更消耗资源呢？（只是了解过）</li><li>有没有看过vue的源码？（没怎么了解过）</li><li>做一道题：判断栈是在哪个容器？（很懵，没看懂题，琢磨了几分钟，面试官提示了pop和push，原来是考栈的先进后出嘛，但是代码没写出来，估计到这里已经凉了）</li><li>说说你这个【搜购】项目具体是怎样的以及主要用了哪些技术？（大体介绍了这个项目，以及自己想完善这个项目的想法）</li><li>顺便说到了另一个【商品收银系统】，讲了一下自己做的时候的难点？（这个问题就是下面一个问题）</li><li>说了一下echarts，以及返回数据显示的坑。（同步与异步造成的问题）</li><li>最后问了一下，你们写的这本书是在校内使用还是要出版发行？（说了一下要出版）</li><li>最后，你有什么问题想问我吗？（以下两个问题）</li><li>1.现在主要学哪一个技术栈好一点？（自己学的是vue，面试官说是根据具体的使用场景进行使用）</li><li>2.对于新出来的东西，是在刚出来的时候就接触，还是在等它成熟了再去使用？（给面试官提了一下刚出来的【快应用】，结果他不知道这个东西。他举例说了一下react native刚出来也不稳定，但是又能够适用的地方，还是会去使用它。）</li></ul><p>OK，面试官：感谢你的时间（顿时心里感觉又凉凉了），收拾简历准备走了，然后叫我把简历留下，不要带走，然后我就直接走了。</p><h3 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h3><p>面试官问项目比较多，注重基础与底层，不要只是会运用，还要知道为什么它能够这样使用，多看看框架的源码。第一次参加面试，还是大厂面试，虽然感觉已经凉了，但是还是一次很不错的体验与经历吧，为自己后面的秋招攒人品吧。</p><script>var _hmt = _hmt || [];(function() {  var hm = document.createElement("script");  hm.src = "https://hm.baidu.com/hm.js?cb26b3220fad854a3119dd8d11ddc6eb";  var s = document.getElementsByTagName("script")[0];   s.parentNode.insertBefore(hm, s);})();</script>]]></content>
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>快运用 | 入门体验小教程 | 快到飞起</title>
      <link href="/2018/04/04/quickApp/"/>
      <content type="html"><![CDATA[<h4 id="什么是快运用"><a href="#什么是快运用" class="headerlink" title="什么是快运用"></a>什么是快运用</h4><ol><li><p>快应用是基于手机硬件平台的新型应用形态，标准是由主流手机厂商组成的快应用联盟联合制定。</p></li><li><p>快应用标准的诞生将在研发接口、能力接入、开发者服务等层面建设标准平台，以平台化的生态模式对个人开发者和企业开发者全品类开放。</p></li><li><p>快应用具备传统APP完整的应用体验，无需安装、即点即用。</p></li></ol><p>详情可见快运用官网<a href="https://www.quickapp.cn/" target="_blank" rel="noopener">官网</a></p><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>2018年3月20日，小米、中兴、华为、金立、联想、魅族、努比亚、OPPO、vivo、一加，共十家手机厂商在北京联合召开快应用标准启动发布会，手机厂商与中国信息通信研究院、电信终端产业协会、中国软件行业协会及数百家知名移动互联网应用企业共襄盛举，共同见证移动应用新生态的到来。</p><p>感觉看起来很牛逼，小编也想去看看究竟是个什么玩意儿。通过小编到官网的一探究竟，发现和Vue.js很相似，不管是结构还是语法上都很类似。好吧，话不多少，随着小编一起去体验一把吧。</p><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><ol><li>这里的入门教程</li><li>一台安卓手机或者是模拟器</li><li>一台电脑</li></ol><h4 id="出发"><a href="#出发" class="headerlink" title="出发"></a>出发</h4><h5 id="1-搭建环境"><a href="#1-搭建环境" class="headerlink" title="1.搭建环境"></a>1.搭建环境</h5><p>【安装node.js】<br>需安装6.0以上版本的NodeJS，请从NodeJS官网下载，推荐v6.11.3<br>注意: 不要使用8.0.*版本．这个版本内部ZipStream实现与node-archive包不兼容，会引起报错<br>这是官方推荐的版本</p><p>【安装工具hap-toolkit】<br>通过npm仓库安装，在命令行中执行以下命令：<br><code>npm install -g hap-toolkit</code><br>在命令行中执行hap -V会输出版本信息表示hap-toolkit安装成功，注意V是大写。</p><p>【创建工程】<br>新建一个文件夹，打开命令行，并cd到新建的文件夹目录下，进行初始化项目，执行以下命令：<br><code>hap init YourProjectName</code><br>【安装依赖】<br>一定要cd到你初始化的项目目录下，不是当前目录哦<br><code>npm install</code><br>【编译项目】<br>在项目文件夹下，执行以下命令：<br><code>npm run build</code><br>这是，可能会报如下的错<br><img src="/images/buildErr.png" alt=""></p><p>淡定，只需要执行一次 hap update –force 即可解决, 对包强制进行升级。<br><img src="/images/ferk.png" alt=""></p><p>然后再执行npm run build进行编译便能成功，可以看到如下界面。<br><img src="/images/build.png" alt=""></p><p>编译成功以后，工程项目会多处两个文件夹：</p><p>build：存放编译后的页面js文件和素材</p><p>dist：存放编译打包生成的rpk压缩文件，这个rpk就是快应用的最终执行文件了。</p><p>【最后一步，预览项目】<br>你的手机或者模拟器需要安装 <a href="https://statres.quickapp.cn/quickapp/quickapp/201803/file/quickapp_debugger.apk" target="_blank" rel="noopener">快应用调试器</a> 和 <a href="https://statres.quickapp.cn/quickapp/quickapp/201803/file/quickapp_platform_preview_release.apk" target="_blank" rel="noopener">平台预览版</a> 下载后用直接USB或者QQ传输安装到手机。注意，两个apk都要安装！平台预览版是模拟快应用的运行时环境的。</p><p>安装前面编译出来的rpk文件</p><p>方法一： 本地安装预览</p><p>将你的工程中/dist目录下编译产出的rpk文件，复制到手机文件系统中。<br>打开手机上的“快应用调试器” 点击“本地安装” 选择手机文件系统前面复制进来的rpk文件，即可预览到你的快应用的界面。</p><p>方法二： 扫码预览<br>在项目文件夹下运行以下命令<br><code>npm run server</code><br>服务器启动后会显示如下的二维码，打开手机上的“快应用调试器”，点击“扫码安装”，扫这个二维码即可安装快应用进行预览。<br><img src="/images/ewm.png" alt=""></p><blockquote><p>推荐使用方法一，方法二可能扫描识别不了二维码。</p></blockquote><p>如果看到如下界面，表示你已经成功开启了【快运用】的大门了，可以愉快的开始学习快运用了。<br><img src="/images/quick2.png" alt=""><br><img src="/images/quick3.png" alt=""><br><img src="/images/quick1.png" alt=""></p><p>OK,至此快运用的介绍就到这里了。如果感兴趣的可以到官网了解更多<a href="https://doc.quickapp.cn/" target="_blank" rel="noopener">官方文档</a></p><script>var _hmt = _hmt || [];(function() {  var hm = document.createElement("script");  hm.src = "https://hm.baidu.com/hm.js?cb26b3220fad854a3119dd8d11ddc6eb";  var s = document.getElementsByTagName("script")[0];   s.parentNode.insertBefore(hm, s);})();</script>]]></content>
      
      <categories>
          
          <category> 快运用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 快运用 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>教学视频 | git的基本命令使用教学视频</title>
      <link href="/2018/04/01/gitLearnMovie/"/>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>git是当今非常流行的版本控制管理器，在项目开发中使用得非常多。但是很多人去网上看着文章学习的时候总会出现一些大大小小的错误，导致操作失败。这是一个全程录制的教学视频，每一步都很详细，希望能够帮助到你并能够顺利的使用git。</p><p>视频中的git命令清单可以参看我的博客<a href="http://blog.54whg.cn/2018/03/17/gitLearn/">【Git 常用的基本命令】</a></p><h3 id="演示视频（可全屏观看）"><a href="#演示视频（可全屏观看）" class="headerlink" title="演示视频（可全屏观看）"></a>演示视频（可全屏观看）</h3><iframe width="696" height="460" src="http://www.iqiyi.com/w_19rygr4jox.html" scrolling="no" frameborder="0" allowfullscreen></iframe><h3 id="git的基本命令"><a href="#git的基本命令" class="headerlink" title="git的基本命令"></a>git的基本命令</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">配置</span><br><span class="line">git config –<span class="keyword">global</span> user.name “Your Name”</span><br><span class="line">git config –<span class="keyword">global</span> user.email “email@example.<span class="keyword">com</span>“</span><br><span class="line"></span><br><span class="line">本地仓库—&gt;远程仓库的基本步骤</span><br><span class="line">git init 新建一个仓库</span><br><span class="line">git status 查看仓库当前的状态</span><br><span class="line">git <span class="built_in">add</span> 可反复多次使用，添加多个文件；</span><br><span class="line">git <span class="built_in">add</span> ./–<span class="keyword">all</span> 添加当前文件夹的所有文件</span><br><span class="line">git commit -<span class="keyword">m</span> “修改内容” 提交到本地仓库</span><br><span class="line">git remote 查看当前配置有哪些远程仓库</span><br><span class="line">git remote <span class="built_in">add</span> origin http<span class="variable">s:</span>//github.<span class="keyword">com</span>/WangHuagang/git-demo.git 将文件添加到指定的GitHub上的仓库</span><br><span class="line">git push -<span class="keyword">u</span> origin master(分支) 将文件推送到远程仓库上</span><br><span class="line">git pull origin master(将远程仓库的东西“拉”回来)</span><br><span class="line"></span><br><span class="line">其余常用的命令</span><br><span class="line">git status -s 查看变更日志</span><br><span class="line">git <span class="built_in">log</span> 可以查看提交日志</span><br><span class="line">git reset –hard (<span class="number">6</span>位版本号) 回归到指定版本</span><br><span class="line">git diff 可以用于对比当前状态和版本库中状态的变化</span><br><span class="line">git branch 查看分支</span><br><span class="line">git branch （分支名） 创建一个新的分支</span><br><span class="line">git checkout （分支名） 切换分支</span><br><span class="line">git clone http<span class="variable">s:</span>//github.<span class="keyword">com</span>/WangHuagang/git-demo.git .(.表示当前目录) 将远程仓库整个项目克隆到当前目录</span><br><span class="line">git merge 合并某分支到当前分支</span><br><span class="line">git branch -d 删除分支</span><br><span class="line"></span><br><span class="line">将本地文件放在github上显示</span><br><span class="line"><span class="number">1</span>.创建gh-pages分支，利用gh-pages分支上传到远程仓库</span><br><span class="line"><span class="number">2</span>.配置文件CNAME：绑定域名</span><br></pre></td></tr></table></figure><script>var _hmt = _hmt || [];(function() {  var hm = document.createElement("script");  hm.src = "https://hm.baidu.com/hm.js?cb26b3220fad854a3119dd8d11ddc6eb";  var s = document.getElementsByTagName("script")[0];   s.parentNode.insertBefore(hm, s);})();</script>]]></content>
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>夜神 Android studio连接配置第三方模拟器·夜神</title>
      <link href="/2018/03/30/Android-studio%E8%BF%9E%E6%8E%A5%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E6%8B%9F%E5%99%A8/"/>
      <content type="html"><![CDATA[<h3 id="Android-Studio怎样连接配置第三方模拟器"><a href="#Android-Studio怎样连接配置第三方模拟器" class="headerlink" title="Android Studio怎样连接配置第三方模拟器"></a>Android Studio怎样连接配置第三方模拟器</h3><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>想必大家都体验了一把Android studio的环境搭建，总会出现莫名其妙的问题，刚刚搭建好，写好“Hello World”准备运行，折腾了半天，结果AS自带的模拟器运行不上，缺少一个加速软件。到这里，心已经凉了一大截了，好吧，换第三方模拟器，genymotion肯定是首选。到官网进行注册，然后下载下来，傻瓜式的安装好genymotion和virtualbox，眼看就要成功了，报错，纳尼！！！居然报错了！没错，他就是报错了。又捣鼓半天，放弃了，再找找其他的第三方模拟器吧，好吧，现在直接步入正题。<br><img src="/images/err.png" alt=""></p><h4 id="夜神模拟器"><a href="#夜神模拟器" class="headerlink" title="夜神模拟器"></a>夜神模拟器</h4><p>夜神安卓模拟器，电脑玩手游的新一代神器。是当前唯一一款采用世界领先的内核技术（基于Android4.4.2 版本内核针在电脑上运行深度开发），具有同类模拟器中最快的运行速度 和最稳定的性能。玩家可以通过本软件在电脑上玩手机游戏， 感受更大的屏幕、更快的速度、更完美的操控体验。<br>直接步入正题。</p><ul><li>下载夜神模拟器  <a href="https://www.yeshen.com/" target="_blank" rel="noopener">官网下载</a></li><li>傻瓜式安装好夜神。</li><li>运行夜神模拟器。<br><img src="/images/yeshen.png" alt=""></li><li>打开命令行窗口。</li><li>cd到夜神的安装目录（如cd D:\Program Files\NOX\Nox\bin）。</li><li>执行以下命令：<code>nox_adb.exe connect 127.0.0.1:62001</code>，连接上模拟器。<br><img src="/images/as3.png" alt=""></li><li>在Android studio中运行app，弹出的ADB中选择连接好的夜神就可以了。<br><img src="/images/as1.png" alt=""><br><img src="/images/as2.png" alt=""></li><li>若Android Studio连接不上夜神，重启连接模拟器即可链接上。</li></ul><hr><p>OK，现在你就可以愉快的敲你的代码了！有什么问题可以给我留言哦。</p><script>var _hmt = _hmt || [];(function() {  var hm = document.createElement("script");  hm.src = "https://hm.baidu.com/hm.js?cb26b3220fad854a3119dd8d11ddc6eb";  var s = document.getElementsByTagName("script")[0];   s.parentNode.insertBefore(hm, s);})();</script>]]></content>
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>计数排序·JavaScript实现</title>
      <link href="/2018/03/29/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
      <content type="html"><![CDATA[<h2 id="计数排序算法"><a href="#计数排序算法" class="headerlink" title="计数排序算法"></a>计数排序算法</h2><h4 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h4><p>计数排序就是遍历数组记录数组下的元素出现过多次，然后把这个元素找个位置先安置下来，简单点说就是以原数组每个元素的值作为新数组的下标，而对应小标的新数组元素的值作为出现的次数，相当于是通过下标进行排序。</p><h4 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h4><p>计数排序的基本思想是对于给定的输入序列中的每一个元素x，确定该序列中值小于x的元素的个数（此处并非比较各元素的大小，而是通过对元素值的计数和计数值的累加来确定）。一旦有了这个信息，就可以将x直接存放到最终的输出序列的正确位置上。例如，如果输入序列中只有17个元素的值小于x的值，则x可以直接存放在输出序列的第18个位置上。</p><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>它的复杂度为Ο(n+k)（其中k是整数的范围）。</p><h4 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h4><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function countingSort(<span class="built_in">array</span>) &#123;</span><br><span class="line">    　　<span class="built_in">var</span> len = <span class="built_in">array</span>.<span class="built_in">length</span>,</span><br><span class="line">    　　B = [],</span><br><span class="line">    　　C = [],</span><br><span class="line">    　　<span class="built_in">min</span> = <span class="built_in">max</span> = <span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">    　　<span class="keyword">for</span> (<span class="built_in">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    　　　　<span class="built_in">min</span> = <span class="built_in">min</span> &lt;= <span class="built_in">array</span>[i] ? <span class="built_in">min</span> : <span class="built_in">array</span>[i];</span><br><span class="line">    　　　　<span class="built_in">max</span> = <span class="built_in">max</span> &gt;= <span class="built_in">array</span>[i] ? <span class="built_in">max</span> : <span class="built_in">array</span>[i];</span><br><span class="line">    　　　　C[<span class="built_in">array</span>[i]] = C[<span class="built_in">array</span>[i]] ? C[<span class="built_in">array</span>[i]] + <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">    　　&#125;</span><br><span class="line">    　　<span class="keyword">for</span> (<span class="built_in">var</span> k = <span class="number">0</span>; k &lt;len; k++) &#123;</span><br><span class="line">    　　　　<span class="built_in">var</span> <span class="built_in">length</span> = C[k];</span><br><span class="line">    　　　　<span class="keyword">for</span>(<span class="built_in">var</span> m = <span class="number">0</span> ;m &lt;<span class="built_in">length</span> ; m++)&#123;</span><br><span class="line">    　　　　　　B.<span class="built_in">push</span>(k);</span><br><span class="line">    　　　　&#125;</span><br><span class="line">    　　&#125;</span><br><span class="line">    　　<span class="built_in">return</span> B;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">var</span> arr = [<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">2</span>];</span><br><span class="line">    console.<span class="built_in">log</span>(countingSort(arr));</span><br></pre></td></tr></table></figure><h4 id="计数排序动画演示"><a href="#计数排序动画演示" class="headerlink" title="计数排序动画演示"></a>计数排序动画演示</h4><p><img src="/images/px/js.gif" alt=""></p><script>var _hmt = _hmt || [];(function() {  var hm = document.createElement("script");  hm.src = "https://hm.baidu.com/hm.js?cb26b3220fad854a3119dd8d11ddc6eb";  var s = document.getElementsByTagName("script")[0];   s.parentNode.insertBefore(hm, s);})();</script>]]></content>
      
      <categories>
          
          <category> js算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>插入排序·JavaScript实现</title>
      <link href="/2018/03/28/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
      <content type="html"><![CDATA[<h2 id="插入排序算法"><a href="#插入排序算法" class="headerlink" title="插入排序算法"></a>插入排序算法</h2><h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><p>插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据。</p><h4 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h4><p>可以这么理解，在一个数组中我们不知道哪个是最小值，那么就假定第一个就是最小值，然后取第二个值与第一个值比较产排序后的序列，然后再取第三个值与排序后的序列进行比较插入到对应的位置，依次类推。</p><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>若数据的初始状态是正序的，那么只需要扫描一趟就完成了。此时是最好的时间复杂度：O(n)。<br>若数据的初始状态是反序的，那么需要扫描n-1次。此时是最坏的时间复杂度：O(n^2)。<br>平均时间：O(n^2)。</p><h4 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h4><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function insertionSort(<span class="built_in">array</span>) &#123;</span><br><span class="line">    　　<span class="keyword">for</span> (<span class="built_in">var</span> i = <span class="number">1</span>; i &lt; <span class="built_in">array</span>.<span class="built_in">length</span>; i++) &#123;</span><br><span class="line">    　　　　<span class="built_in">var</span> <span class="built_in">key</span> = <span class="built_in">array</span>[i];</span><br><span class="line">    　　　　<span class="built_in">var</span> j = i - <span class="number">1</span>;</span><br><span class="line">    　　　　<span class="keyword">while</span> ( <span class="built_in">array</span>[j] &gt; <span class="built_in">key</span>) &#123;</span><br><span class="line">    　　　　　　<span class="built_in">array</span>[j + <span class="number">1</span>] = <span class="built_in">array</span>[j];</span><br><span class="line">    　　　　　    j--;</span><br><span class="line">    　　　　&#125;</span><br><span class="line">    　　　　<span class="built_in">array</span>[j + <span class="number">1</span>] = <span class="built_in">key</span>;</span><br><span class="line">    　　&#125;</span><br><span class="line">    　　<span class="built_in">return</span> <span class="built_in">array</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">var</span> arr=[<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">4</span>];</span><br><span class="line">    console.<span class="built_in">log</span>(insertionSort(arr));</span><br></pre></td></tr></table></figure><h4 id="插入排序动画演示"><a href="#插入排序动画演示" class="headerlink" title="插入排序动画演示"></a>插入排序动画演示</h4><p><img src="/images/px/cr.gif" alt=""></p><!-- <script>var _hmt = _hmt || [];(function() {  var hm = document.createElement("script");  hm.src = "https://hm.baidu.com/hm.js?cb26b3220fad854a3119dd8d11ddc6eb";  var s = document.getElementsByTagName("script")[0];   s.parentNode.insertBefore(hm, s);})();</script> -->]]></content>
      
      <categories>
          
          <category> js算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>快速排序·JavaScript实现</title>
      <link href="/2018/03/27/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
      <content type="html"><![CDATA[<h2 id="快速排序算法"><a href="#快速排序算法" class="headerlink" title="快速排序算法"></a>快速排序算法</h2><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p><h4 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h4><p>可以这么理解，在一个数组中我们不知道哪个是最小值，那么就假定第一个就是最小值，然后取第二个值与第一个值比较产排序后的序列，然后再取第三个值与排序后的序列进行比较插入到对应的位置，依次类推。</p><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>若数据的初始状态是正序的，那么只需要扫描一趟就完成了。此时是最好的时间复杂度：O(n)。<br>若数据的初始状态是反序的，那么需要扫描n-1次。此时是最坏的时间复杂度：O(n^2)。<br>平均时间：O(n^2)。</p><h4 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">quickSort</span> = function(arr) &#123;</span><br><span class="line">    　　<span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) &#123; <span class="keyword">return</span> arr; &#125;</span><br><span class="line">    　　<span class="keyword">var</span> pivotIndex = <span class="type">Math</span>.floor(arr.length / <span class="number">2</span>);</span><br><span class="line">    　　<span class="keyword">var</span> pivot = arr.splice(pivotIndex, <span class="number">1</span>)[<span class="number">0</span>];</span><br><span class="line">    　　console.log(pivot);<span class="comment">//查看每一次的中间点</span></span><br><span class="line">    　　<span class="keyword">var</span> <span class="keyword">left</span> = [];</span><br><span class="line">    　　<span class="keyword">var</span> <span class="keyword">right</span> = [];</span><br><span class="line">    　　<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">    　　　　<span class="keyword">if</span> (arr[i] &lt; pivot) &#123;</span><br><span class="line">    　　　　　　<span class="keyword">left</span>.push(arr[i]);</span><br><span class="line">    　　　　&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    　　　　　　<span class="keyword">right</span>.push(arr[i]);</span><br><span class="line">    　　　　&#125;</span><br><span class="line">    　　&#125;</span><br><span class="line">    　　<span class="keyword">return</span> <span class="built_in">quickSort</span>(<span class="keyword">left</span>).concat([pivot], <span class="built_in">quickSort</span>(<span class="keyword">right</span>));</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">var</span> arr=[<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">4</span>];</span><br><span class="line">    console.log(<span class="built_in">quickSort</span>(arr));</span><br></pre></td></tr></table></figure><h4 id="快速排序动画演示"><a href="#快速排序动画演示" class="headerlink" title="快速排序动画演示"></a>快速排序动画演示</h4><p><img src="/images/px/ks.gif" alt=""></p><blockquote><p>转载文章时请注明本文的出处 || <a href="http://www.blog.54whg.cn" target="_blank" rel="noopener">咕噜先森的博客</a> 作者-&gt;@王华港</p></blockquote><script>var _hmt = _hmt || [];(function() {  var hm = document.createElement("script");  hm.src = "https://hm.baidu.com/hm.js?cb26b3220fad854a3119dd8d11ddc6eb";  var s = document.getElementsByTagName("script")[0];   s.parentNode.insertBefore(hm, s);})();</script>]]></content>
      
      <categories>
          
          <category> js算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>选择排序·JavaScript实现</title>
      <link href="/2018/03/26/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
      <content type="html"><![CDATA[<h2 id="选择排序算法"><a href="#选择排序算法" class="headerlink" title="选择排序算法"></a>选择排序算法</h2><h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p>选择排序是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。</p><h4 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h4><p>对比数组中前一个元素跟后一个元素的大小，如果后面的元素比前面的元素小则用一个变量k来记住他的位置，接着第二次比较，前面“后一个元素”现变成了“前一个元素”，继续跟他的“后一个元素”进行比较如果后面的元素比他要小则用变量k记住它在数组中的位置(下标)，等到循环结束的时候，我们应该找到了最小的那个数的下标了，然后进行判断，如果这个元素的下标不是第一个元素的下标，就让第一个元素跟他交换一下值，这样就找到整个数组中最小的数了。然后找到数组中第二小的数，让他跟数组中第二个元素交换一下值，以此类推。</p><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>若数据的初始状态是正序的，那此时是最好的时间复杂度：O(n^2)。<br>若数据的初始状态是反序的，那么需要扫描n-1次。此时是最坏的时间复杂度：O(n^2)。<br>平均时间：O(n^2)。</p><h4 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">xz</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len=arr.length;</span><br><span class="line">    <span class="keyword">var</span> minIndex,temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;len<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        minIndex=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j=i+<span class="number">1</span>;j&lt;len;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j]&lt;arr[minIndex])&#123;<span class="comment">//判断更小的数</span></span><br><span class="line">                minIndex=j; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp=arr[i];</span><br><span class="line">        arr[i]=arr[minIndex];</span><br><span class="line">        arr[minIndex]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr=[<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">4</span>];</span><br><span class="line"><span class="built_in">console</span>.log(xz(arr))</span><br></pre></td></tr></table></figure><h4 id="选择排序动画演示"><a href="#选择排序动画演示" class="headerlink" title="选择排序动画演示"></a>选择排序动画演示</h4><p><img src="/images/px/xz.gif" alt=""></p><blockquote><p>当数据量比较小时（1000左右），使用选择排序比冒泡排序更快。</p></blockquote><blockquote><p>转载文章时请注明本文的出处 || <a href="http://www.blog.54whg.cn" target="_blank" rel="noopener">咕噜先森的博客</a> 作者-&gt;@王华港</p></blockquote><script>var _hmt = _hmt || [];(function() {  var hm = document.createElement("script");  hm.src = "https://hm.baidu.com/hm.js?cb26b3220fad854a3119dd8d11ddc6eb";  var s = document.getElementsByTagName("script")[0];   s.parentNode.insertBefore(hm, s);})();</script>]]></content>
      
      <categories>
          
          <category> js算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>冒泡排序·JavaScript实现</title>
      <link href="/2018/03/25/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
      <content type="html"><![CDATA[<h2 id="冒泡排序算法"><a href="#冒泡排序算法" class="headerlink" title="冒泡排序算法"></a>冒泡排序算法</h2><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。</p><h4 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h4><p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。<br>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。<br>针对所有的元素重复以上的步骤，除了最后一个。<br>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>若数据的初始状态是正序的，那么只需要扫描一趟就完成了。此时是最好的时间复杂度：O(n)。<br>若数据的初始状态是反序的，那么需要扫描n-1次。此时是最坏的时间复杂度：O(n^2)。<br>平均时间：O(n^2)。</p><h4 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h4><p>1.最基础，也是最容易理解的一种做法。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function bubbleSort(arr) &#123;</span><br><span class="line">　　var len = arr.length;</span><br><span class="line">　　for (var i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">　　　　for (var j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">　　　　　　if (arr[j] &gt; arr[j+<span class="number">1</span>]) &#123; <span class="comment">//相邻元素两两对比</span></span><br><span class="line">　　　　　　　　var temp = arr[j+<span class="number">1</span>]; <span class="comment">//元素交换</span></span><br><span class="line">　　　　　　　　arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">　　　　　　　　arr[j] = temp;</span><br><span class="line">　　　　　　&#125;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">　　return arr;</span><br><span class="line">&#125;</span><br><span class="line">var arr=[<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">4</span>];</span><br><span class="line">console.log(bubbleSort(arr));</span><br></pre></td></tr></table></figure></p><p>2.更简单一点的，但不是那么容易理解的一种算法。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function bubbleSort2(arr) &#123;</span><br><span class="line">　　var i = arr.length<span class="number">-1</span>; <span class="comment">//初始时,最后位置保持不变　　</span></span><br><span class="line">　　while ( i&gt; <span class="number">0</span>) &#123;</span><br><span class="line">　　　　var pos= <span class="number">0</span>; <span class="comment">//每趟开始时,无记录交换</span></span><br><span class="line">　　　　for (var j= <span class="number">0</span>; j&lt; i; j++)&#123;</span><br><span class="line">　　　　　　if (arr[j]&gt; arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">　　　　　　　　pos= j; <span class="comment">//记录交换的位置</span></span><br><span class="line">　　　　　　　　var tmp = arr[j]; arr[j]=arr[j+<span class="number">1</span>];arr[j+<span class="number">1</span>]=tmp;</span><br><span class="line">　　　　　　&#125;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　　i= pos; <span class="comment">//为下一趟排序作准备</span></span><br><span class="line">　　&#125;</span><br><span class="line">　　return arr;</span><br><span class="line">&#125;</span><br><span class="line">var arr=[<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">4</span>];</span><br><span class="line">console.log(bubbleSort2(arr));</span><br></pre></td></tr></table></figure></p><h4 id="冒泡排序动画演示"><a href="#冒泡排序动画演示" class="headerlink" title="冒泡排序动画演示"></a>冒泡排序动画演示</h4><p><img src="/images/px/mp.gif" alt=""></p><blockquote><p>转载文章时请注明本文的出处 || <a href="http://www.blog.54whg.cn" target="_blank" rel="noopener">咕噜先森的博客</a> 作者-&gt;@王华港</p></blockquote><script>var _hmt = _hmt || [];(function() {  var hm = document.createElement("script");  hm.src = "https://hm.baidu.com/hm.js?cb26b3220fad854a3119dd8d11ddc6eb";  var s = document.getElementsByTagName("script")[0];   s.parentNode.insertBefore(hm, s);})();</script>]]></content>
      
      <categories>
          
          <category> js算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【每日9个】CSS3重要知识点总结（五）（完结）</title>
      <link href="/2018/03/24/css305/"/>
      <content type="html"><![CDATA[<p><img src="/images/pic/09.jpg" alt=""></p><h2 id="1-position-fixed-在android下无效怎么处理？"><a href="#1-position-fixed-在android下无效怎么处理？" class="headerlink" title="1.position:fixed;在android下无效怎么处理？"></a>1.position:fixed;在android下无效怎么处理？</h2><p><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no&quot;/&gt;</code></p><h2 id="2-如果需要手动写动画，你认为最小时间间隔是多久，为什么？"><a href="#2-如果需要手动写动画，你认为最小时间间隔是多久，为什么？" class="headerlink" title="2.如果需要手动写动画，你认为最小时间间隔是多久，为什么？"></a>2.如果需要手动写动画，你认为最小时间间隔是多久，为什么？</h2><p>多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms。</p><h2 id="3-li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？"><a href="#3-li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？" class="headerlink" title="3.li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？"></a>3.li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？</h2><p>行框的排列会受到中间空白（回车空格）等的影响，因为空格也属于字符,这些空白也会被应用样式，占据空间，所以会有间隔，把字符大小设为0，就没有空格了。<br>解决方法：<br>1.可以将<code>&lt;li&gt;</code>代码全部写在一排<br>2.浮动li中float：left<br>3.在ul中用font-size：0（谷歌不支持）；可以使用letter-space：-3px</p><h2 id="4-display-inline-block-什么时候会显示间隙？"><a href="#4-display-inline-block-什么时候会显示间隙？" class="headerlink" title="4.display:inline-block 什么时候会显示间隙？"></a>4.display:inline-block 什么时候会显示间隙？</h2><p>1.有空格时候会有间隙 解决：移除空格<br>2.margin正值的时候 解决：margin使用负值<br>3.使用font-size时候 解决：font-size:0、letter-spacing、word-spacing</p><h2 id="5-有一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度"><a href="#5-有一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度" class="headerlink" title="5.有一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度"></a>5.有一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度</h2><p>外层div使用position：relative；高度要求自适应的div使用position: absolute; top: 100px; bottom: 0; left: 0</p><h2 id="6-png、jpg、gif-这些图片格式解释一下，分别什么时候用。有没有了解过webp？"><a href="#6-png、jpg、gif-这些图片格式解释一下，分别什么时候用。有没有了解过webp？" class="headerlink" title="6.png、jpg、gif 这些图片格式解释一下，分别什么时候用。有没有了解过webp？"></a>6.png、jpg、gif 这些图片格式解释一下，分别什么时候用。有没有了解过webp？</h2><p>1    png是便携式网络图片（Portable Network Graphics）是一种无损数据压缩位图文件格式.优点是：压缩比高，色彩好。 大多数地方都可以用。<br>2.jpg是一种针对相片使用的一种失真压缩方法，是一种破坏性的压缩，在色调及颜色平滑变化做的不错。在www上，被用来储存和传输照片的格式。<br>3.gif是一种位图文件格式，以8位色重现真色彩的图像。可以实现动画效果.<br>4.webp格式是谷歌在2010年推出的图片格式，压缩率只有jpg的2/3，大小比png小了45%。缺点是压缩的时间更久了，兼容性不好，目前谷歌和opera支持。</p><h2 id="7-style标签写在body后与body前有什么区别？"><a href="#7-style标签写在body后与body前有什么区别？" class="headerlink" title="7.style标签写在body后与body前有什么区别？"></a>7.style标签写在body后与body前有什么区别？</h2><p>页面加载自上而下 当然是先加载样式。<br>写在body标签后由于浏览器以逐行方式对HTML文档进行解析，当解析到写在尾部的样式表（外联或写在style标签）会导致浏览器停止之前的渲染，等待加载且解析样式表完成之后重新渲染，在windows的IE下可能会出现FOUC现象（即样式失效导致的页面闪烁问题）</p><h2 id="8-CSS属性overflow属性定义溢出元素内容区的内容会如何处理"><a href="#8-CSS属性overflow属性定义溢出元素内容区的内容会如何处理" class="headerlink" title="8.CSS属性overflow属性定义溢出元素内容区的内容会如何处理?"></a>8.CSS属性overflow属性定义溢出元素内容区的内容会如何处理?</h2><p>参数是scroll时候，必会出现滚动条。<br>参数是auto时候，子元素内容大于父元素时出现滚动条。<br>参数是visible时候，溢出的内容出现在父元素之外。<br>参数是hidden时候，溢出隐藏。</p><h2 id="9-阐述一下CSS-Sprites"><a href="#9-阐述一下CSS-Sprites" class="headerlink" title="9.阐述一下CSS Sprites"></a>9.阐述一下CSS Sprites</h2><p>将一个页面涉及到的所有图片都包含到一张大图中去，然后利用CSS的 background-image，background- repeat，background-position 的组合进行背景定位。利用CSS Sprites能很好地减少网页的http请求，从而大大的提高页面的性能；CSS Sprites能减少图片的字节.</p><blockquote><p>转载文章时请注明本文的出处 || <a href="http://www.blog.54whg.cn" target="_blank" rel="noopener">咕噜先森的博客</a> 作者-&gt;@王华港</p></blockquote><script>var _hmt = _hmt || [];(function() {  var hm = document.createElement("script");  hm.src = "https://hm.baidu.com/hm.js?cb26b3220fad854a3119dd8d11ddc6eb";  var s = document.getElementsByTagName("script")[0];   s.parentNode.insertBefore(hm, s);})();</script>]]></content>
      
      <categories>
          
          <category> CSS3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS3 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【每日9个】CSS3重要知识点总结（四）</title>
      <link href="/2018/03/22/css304/"/>
      <content type="html"><![CDATA[<p><img src="/images/pic/09.jpg" alt=""></p><h2 id="1-margin和padding分别适合什么场景使用？"><a href="#1-margin和padding分别适合什么场景使用？" class="headerlink" title="1.margin和padding分别适合什么场景使用？"></a>1.margin和padding分别适合什么场景使用？</h2><p>何时使用margin：<br>1.需要在border外侧添加空白<br>2.空白处不需要背景色<br>3.上下相连的两个盒子之间的空白，需要相互抵消时。<br>何时使用padding：<br>1.需要在border内侧添加空白<br>2.空白处需要背景颜色<br>3.上下相连的两个盒子的空白，希望为两者之和。</p><p>兼容性的问题：在IE5 IE6中，为float的盒子指定margin时，左侧的margin可能会变成两倍的宽度。通过改变padding或者指定盒子的display：inline解决。</p><h2 id="2-元素竖向的百分比设定是相对于容器的高度吗？"><a href="#2-元素竖向的百分比设定是相对于容器的高度吗？" class="headerlink" title="2.元素竖向的百分比设定是相对于容器的高度吗？"></a>2.元素竖向的百分比设定是相对于容器的高度吗？</h2><p>当按百分比设定一个元素的宽度时，它是相对于父容器的<strong>宽度</strong>计算的，但是，对于一些表示竖向距离的属性，例如 padding-top , padding-bottom , margin-top , margin-bottom 等，当按百分比设定它们时，依据的也是父容器的<strong>宽度</strong>，而不是高度。</p><h2 id="3-全屏滚动的原理是什么？用到了CSS的哪些属性？"><a href="#3-全屏滚动的原理是什么？用到了CSS的哪些属性？" class="headerlink" title="3.全屏滚动的原理是什么？用到了CSS的哪些属性？"></a>3.全屏滚动的原理是什么？用到了CSS的哪些属性？</h2><p>1.原理：有点类似于轮播，整体的元素一直排列下去，假设有5个需要展示的全屏页面，那么高度是500%，只是展示100%，剩下的可以通过transform进行y轴定位，也可以通过margin-top实现<br>2.overflow：hidden；transition：all 1000ms ease；</p><h2 id="4-什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？"><a href="#4-什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？" class="headerlink" title="4.什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？"></a>4.什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？</h2><p>响应式网站设计是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。<br>基本原理是通过媒体查询检测不同的设备屏幕尺寸做处理。<br>页面头部必须有meta声明的viewport。<br><code>&lt;meta name=&quot;’viewport’&quot; content=&quot;”width=device-width,&quot; initial-scale=&quot;1.&quot; maximum-scale=&quot;1,user-scalable=no”&quot;/&gt;</code></p><h2 id="5-视差滚动效果？"><a href="#5-视差滚动效果？" class="headerlink" title="5.视差滚动效果？"></a>5.视差滚动效果？</h2><p>视差滚动通过在网页向下滚动的时候，控制背景的移动速度比前景的移动速度慢来创建出令人惊叹的3D效果。<br>1.CSS3实现<br>优点：开发时间短、性能和开发效率比较好，缺点是不能兼容到低版本的浏览器<br>2.jQuery实现<br>通过控制不同层滚动速度，计算每一层的时间，控制滚动效果。<br>优点：能兼容到各个版本的，效果可控性好<br>缺点：开发起来对制作者要求高<br>3.插件实现方式<br>例如：parallax-scrolling，兼容性十分好,<a href="http://www.bluesdream.com/case/jquery/jquery-parallax-scrolling/" target="_blank" rel="noopener">在线demo</a></p><h2 id="6-before-和-after中双冒号和单冒号有什么区别？解释一下这2个伪元素的作用"><a href="#6-before-和-after中双冒号和单冒号有什么区别？解释一下这2个伪元素的作用" class="headerlink" title="6.::before 和 :after中双冒号和单冒号有什么区别？解释一下这2个伪元素的作用"></a>6.::before 和 :after中双冒号和单冒号有什么区别？解释一下这2个伪元素的作用</h2><p>1.单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。<br>2.::before就是以一个子元素的存在，定义在元素主体内容之前的一个伪元素。并不存在于dom之中，只存在在页面之中。<br>:before 和 :after 这两个伪元素，是在CSS2.1里新出现的。起初，伪元素的前缀使用的是单冒号语法，但随着Web的进化，在CSS3的规范里，伪元素的语法被修改成使用双冒号，成为::before ::after</p><h2 id="7-你对line-height是如何理解的？"><a href="#7-你对line-height是如何理解的？" class="headerlink" title="7.你对line-height是如何理解的？"></a>7.你对line-height是如何理解的？</h2><p>行高是指一行文字的高度，具体说是两行文字间基线的距离。CSS中起高度作用的是height和line-height，没有定义height属性，最终其表现作用一定是line-height。<br>单行文本垂直居中：把line-height值设置为height一样大小的值可以实现单行文字的垂直居中，其实也可以把height删除。<br>多行文本垂直居中：需要设置display属性为inline-block。</p><h2 id="8-怎么让Chrome支持小于12px-的文字？"><a href="#8-怎么让Chrome支持小于12px-的文字？" class="headerlink" title="8.怎么让Chrome支持小于12px 的文字？"></a>8.怎么让Chrome支持小于12px 的文字？</h2><p>p{font-size:10px;-webkit-transform:scale(0.8);} //0.8是缩放比例</p><h2 id="9-让页面里的字体变清晰，变细用CSS怎么做？"><a href="#9-让页面里的字体变清晰，变细用CSS怎么做？" class="headerlink" title="9.让页面里的字体变清晰，变细用CSS怎么做？"></a>9.让页面里的字体变清晰，变细用CSS怎么做？</h2><p>-webkit-font-smoothing在window系统下没有起作用，但是在IOS设备上起作用-webkit-font-smoothing：antialiased是最佳的，灰度平滑。</p><blockquote><p>转载文章时请注明本文的出处 || <a href="http://www.blog.54whg.cn" target="_blank" rel="noopener">咕噜先森的博客</a> 作者-&gt;@王华港</p></blockquote><script>var _hmt = _hmt || [];(function() {  var hm = document.createElement("script");  hm.src = "https://hm.baidu.com/hm.js?cb26b3220fad854a3119dd8d11ddc6eb";  var s = document.getElementsByTagName("script")[0];   s.parentNode.insertBefore(hm, s);})();</script>]]></content>
      
      <categories>
          
          <category> CSS3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS3 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【每日9个】CSS3重要知识点总结（三）</title>
      <link href="/2018/03/21/css303/"/>
      <content type="html"><![CDATA[<p><img src="/images/pic/08.jpg" alt=""></p><h2 id="1-对BFC规范-块级格式化上下文：block-formatting-context-的理解"><a href="#1-对BFC规范-块级格式化上下文：block-formatting-context-的理解" class="headerlink" title="1.对BFC规范(块级格式化上下文：block formatting context)的理解"></a>1.对BFC规范(块级格式化上下文：block formatting context)的理解</h2><p>BFC规定了内部的Block Box如何布局。<br>定位方案：<br>1.内部的Box会在垂直方向上一个接一个放置。<br>2.Box垂直方向的距离由margin决定，属于同一个BFC的两个相邻Box的margin会发生重叠。<br>3.每个元素的margin box 的左边，与包含块border box的左边相接触。<br>4.BFC的区域不会与float box重叠。<br>5.BFC是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。<br>6.计算BFC的高度时，浮动元素也会参与计算。<br>满足下列条件之一就可触发BFC<br>1.根元素，即html<br>2.float的值不为none（默认）<br>3.overflow的值不为visible（默认）<br>4.display的值为inline-block、table-cell、table-caption<br>5.position的值为absolute或fixed</p><h2 id="2-为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式？"><a href="#2-为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式？" class="headerlink" title="2.为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式？"></a>2.为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式？</h2><p>浮动元素碰到包含它的边框或者浮动元素的边框停留。由于浮动元素不在文档流中，所以文档流的块框表现得就像浮动框不存在一样。浮动元素会漂浮在文档流的块框上。<br>浮动带来的问题：<br>1.父元素的高度无法被撑开，影响与父元素同级的元素<br>2.与浮动元素同级的非浮动元素（内联元素）会跟随其后<br>3.若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构。<br>清除浮动的方式：<br>1.父级div定义height<br>2.最后一个浮动元素后加空div标签 并添加样式clear:both。<br>3.包含浮动元素的父标签添加样式overflow为hidden或auto。<br>4.父级div定义zoom</p><h2 id="3-上下margin重合的问题"><a href="#3-上下margin重合的问题" class="headerlink" title="3.上下margin重合的问题"></a>3.上下margin重合的问题</h2><p>在重合元素外包裹一层容器，并触发该容器生成一个BFC。<br>例子：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span> class=<span class="string">"aside"</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;<span class="selector-tag">div</span> class=<span class="string">"text"</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span> class=<span class="string">"main"</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;!--下面是css代码--&gt;</span><br><span class="line"><span class="selector-class">.aside</span> &#123;</span><br><span class="line">            <span class="attribute">margin-bottom</span>: <span class="number">100px</span>;  </span><br><span class="line">            <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">            <span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line">            <span class="attribute">background</span>: <span class="number">#f66</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="selector-class">.main</span> &#123;</span><br><span class="line">            <span class="attribute">margin-top</span>: <span class="number">100px</span>;</span><br><span class="line">            <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">            <span class="attribute">background</span>: <span class="number">#fcc</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         .text&#123;</span><br><span class="line">            <span class="comment">/*盒子main的外面包一个div，通过改变此div的属性使两个盒子分属于两个不同的BFC，以此来阻止margin重叠*/</span></span><br><span class="line">            <span class="attribute">overflow</span>: hidden;  <span class="comment">//此时已经触发了BFC属性。</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><h2 id="4-设置元素浮动后，该元素的display值是多少？"><a href="#4-设置元素浮动后，该元素的display值是多少？" class="headerlink" title="4.设置元素浮动后，该元素的display值是多少？"></a>4.设置元素浮动后，该元素的display值是多少？</h2><p>自动变成display:block.</p><h2 id="5-移动端的布局用过媒体查询吗？"><a href="#5-移动端的布局用过媒体查询吗？" class="headerlink" title="5.移动端的布局用过媒体查询吗？"></a>5.移动端的布局用过媒体查询吗？</h2><p>通过媒体查询可以为不同大小和尺寸的媒体定义不同的css，适应相应的设备的显示。<br>1.<head>里边&lt;link rel=”stylesheet” type=”text/css” href=”xxx.css” media=”only screen and (max-device-width:480px)”&gt;<br>2.CSS : @media only screen and (max-device-width:480px) {/css样式/}</head></p><h2 id="6-CSS-预处理器"><a href="#6-CSS-预处理器" class="headerlink" title="6.CSS 预处理器"></a>6.CSS 预处理器</h2><p>Less和sass，具体的可以自行了解一下。</p><h2 id="7-CSS优化、提高性能的方法有哪些？"><a href="#7-CSS优化、提高性能的方法有哪些？" class="headerlink" title="7.CSS优化、提高性能的方法有哪些？"></a>7.CSS优化、提高性能的方法有哪些？</h2><p>1.避免过度约束<br>2.避免后代选择符<br>3.避免链式选择符<br>4.使用紧凑的语法<br>5.避免不必要的命名空间<br>6.避免不必要的重复<br>7.最好使用表示语义的名字。一个好的类名应该是描述他是什么而不是像什么<br>8.避免！important，可以选择其他选择器<br>9.尽可能的精简规则，你可以合并不同类里的重复规则</p><h2 id="8-浏览器是怎样解析CSS选择器的？"><a href="#8-浏览器是怎样解析CSS选择器的？" class="headerlink" title="8.浏览器是怎样解析CSS选择器的？"></a>8.浏览器是怎样解析CSS选择器的？</h2><p>CSS选择器的解析是从右向左解析的。若从左向右的匹配，发现不符合规则，需要进行回溯，会损失很多性能。若从右向左匹配，先找到所有的最右节点，对于每一个节点，向上寻找其父节点直到找到根元素或满足条件的匹配规则，则结束这个分支的遍历。两种匹配规则的性能差别很大，是因为从右向左的匹配在第一步就筛选掉了大量的不符合条件的最右节点（叶子节点），而从左向右的匹配规则的性能都浪费在了失败的查找上面。<br>而在 CSS 解析完毕后，需要将解析的结果与 DOM Tree 的内容一起进行分析建立一棵 Render Tree，最终用来进行绘图。在建立 Render Tree 时（WebKit 中的「Attachment」过程），浏览器就要为每个 DOM Tree 中的元素根据 CSS 的解析结果（Style Rules）来确定生成怎样的 Render Tree。</p><h2 id="9-在网页中的应该使用奇数还是偶数的字体？为什么呢？"><a href="#9-在网页中的应该使用奇数还是偶数的字体？为什么呢？" class="headerlink" title="9.在网页中的应该使用奇数还是偶数的字体？为什么呢？"></a>9.在网页中的应该使用奇数还是偶数的字体？为什么呢？</h2><p>使用偶数字体。偶数字号相对更容易和 web 设计的其他部分构成比例关系。Windows 自带的点阵宋体（中易宋体）从 Vista 开始只提供 12、14、16 px 这三个大小的点阵，而 13、15、17 px时用的是小一号的点。（即每个字占的空间大了 1 px，但点阵没变），于是略显稀疏。</p><blockquote><p>转载文章时请注明本文的出处 || <a href="http://www.blog.54whg.cn" target="_blank" rel="noopener">咕噜先森的博客</a> 作者-&gt;@王华港</p></blockquote><script>var _hmt = _hmt || [];(function() {  var hm = document.createElement("script");  hm.src = "https://hm.baidu.com/hm.js?cb26b3220fad854a3119dd8d11ddc6eb";  var s = document.getElementsByTagName("script")[0];   s.parentNode.insertBefore(hm, s);})();</script>]]></content>
      
      <categories>
          
          <category> CSS3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS3 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【每日9个】CSS3重要知识点总结（二）</title>
      <link href="/2018/03/20/css302/"/>
      <content type="html"><![CDATA[<p><img src="/images/pic/07.jpg" alt=""></p><h2 id="1-请解释一下CSS3的flexbox（弹性盒布局模型）-以及适用场景？"><a href="#1-请解释一下CSS3的flexbox（弹性盒布局模型）-以及适用场景？" class="headerlink" title="1.请解释一下CSS3的flexbox（弹性盒布局模型）,以及适用场景？"></a>1.请解释一下CSS3的flexbox（弹性盒布局模型）,以及适用场景？</h2><p>该布局模型的目的是提供一种更加高效的方式来对容器中的条目进行布局、对齐和分配空间。在传统的布局方式中，block 布局是把块在垂直方向从上到下依次排列的；而 inline 布局则是在水平方向来排列。弹性盒布局并没有这样内在的方向限制，可以由开发人员自由操作。<br>试用场景：弹性布局适合于移动前端开发，在Android和ios上也完美支持。</p><h2 id="2-用纯CSS创建一个三角形的原理是什么？"><a href="#2-用纯CSS创建一个三角形的原理是什么？" class="headerlink" title="2.用纯CSS创建一个三角形的原理是什么？"></a>2.用纯CSS创建一个三角形的原理是什么？</h2><p>首先，需要把元素的宽度、高度设为0。然后设置边框样式。<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">border-top</span>: <span class="number">40px</span> solid transparent;</span><br><span class="line"><span class="attribute">border-left</span>: <span class="number">40px</span> solid transparent;</span><br><span class="line"><span class="attribute">border-right</span>: <span class="number">40px</span> solid transparent;</span><br><span class="line"><span class="attribute">border-bottom</span>: <span class="number">40px</span> solid <span class="number">#ff0000</span>;</span><br></pre></td></tr></table></figure></p><h2 id="3-一个满屏品字布局如何设计"><a href="#3-一个满屏品字布局如何设计" class="headerlink" title="3.一个满屏品字布局如何设计?"></a>3.一个满屏品字布局如何设计?</h2><p>第一种真正的品字：</p><ol><li>三块高宽是确定的；</li><li>上面那块用margin: 0 auto;居中；</li><li>下面两块用float或者inline-block不换行；</li><li>用margin调整位置使他们居中。</li></ol><p>第二种全屏的品字布局:<br>上面的div设置成100%，下面的div分别宽50%，然后使用float或者inline使其不换行。</p><h2 id="4-常见的兼容性问题？"><a href="#4-常见的兼容性问题？" class="headerlink" title="4.常见的兼容性问题？"></a>4.常见的兼容性问题？</h2><ol><li>不同浏览器的标签默认的margin和padding不一样。*{margin:0;padding:0;}</li><li>IE6双边距bug：块属性标签float后，又有横行的margin情况下，在IE6显示margin比设置的大。hack：display:inline;将其转化为行内属性。</li><li><p>渐进识别的方式，从总体中逐渐排除局部。首先，巧妙的使用“9”这一标记，将IE浏览器从所有情况中分离出来。接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attribute">background-color</span>:<span class="number">#f1ee18</span>;<span class="comment">/*所有识别*/</span></span><br><span class="line"><span class="selector-class">.background-color</span>:<span class="number">#00deff</span>\<span class="number">9</span>; <span class="comment">/*IE6、7、8识别*/</span></span><br><span class="line">+<span class="attribute">background-color</span>:<span class="number">#a200ff</span>;<span class="comment">/*IE6、7识别*/</span></span><br><span class="line">_background-<span class="attribute">color</span>:<span class="number">#1e0bd1</span>;<span class="comment">/*IE6识别*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>设置较小高度标签（一般小于10px），在IE6，IE7中高度超出自己设置高度。hack：给超出高度的标签设置overflow:hidden;或者设置行高line-height 小于你设置的高度。</p></li><li>IE下，可以使用获取常规属性的方法来获取自定义属性,也可以使用getAttribute()获取自定义属性；Firefox下，只能使用getAttribute()获取自定义属性。解决方法:统一通过getAttribute()获取自定义属性。</li><li>Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示,可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决。</li><li>超链接访问过后hover样式就不出现了，被点击访问过的超链接样式不再具有hover和active了。解决方法是改变CSS属性的排列顺序:L-V-H-A ( love hate ): a:link {} a:visited {} a:hover {} a:active {}</li></ol><h2 id="5-为什么要初始化CSS样式"><a href="#5-为什么要初始化CSS样式" class="headerlink" title="5.为什么要初始化CSS样式"></a>5.为什么要初始化CSS样式</h2><p>因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。</p><h2 id="6-absolute的containing-block计算方式跟正常流有什么不同？"><a href="#6-absolute的containing-block计算方式跟正常流有什么不同？" class="headerlink" title="6.absolute的containing block计算方式跟正常流有什么不同？"></a>6.absolute的containing block计算方式跟正常流有什么不同？</h2><p>无论属于哪种，都要先找到其祖先元素中最近的 position 值不为 static 的元素，然后再判断：</p><ol><li>若此元素为 inline 元素，则 containing block 为能够包含这个元素生成的第一个和最后一个 inline box 的 padding box (除 margin, border 外的区域) 的最小矩形；</li><li>否则,则由这个祖先元素的 padding box 构成。</li></ol><p>如果都找不到，则为 initial containing block。<br>补充：</p><ol><li>static(默认的)/relative：简单说就是它的父元素的内容框（即去掉padding的部分）</li><li>absolute: 向上找最近的定位为absolute/relative的元素</li><li>fixed: 它的containing block一律为根元素(html/body)</li></ol><h2 id="7-CSS里的visibility属性有个collapse属性值？在不同浏览器下以后什么区别？"><a href="#7-CSS里的visibility属性有个collapse属性值？在不同浏览器下以后什么区别？" class="headerlink" title="7.CSS里的visibility属性有个collapse属性值？在不同浏览器下以后什么区别？"></a>7.CSS里的visibility属性有个collapse属性值？在不同浏览器下以后什么区别？</h2><p>当一个元素的visibility属性被设置成collapse值后，对于一般的元素，它的表现跟hidden是一样的。</p><ol><li>chrome中，使用collapse值和使用hidden没有区别。</li><li>firefox，opera和IE，使用collapse值和使用display：none没有什么区别。</li></ol><h2 id="8-display-none与visibility：hidden的区别？"><a href="#8-display-none与visibility：hidden的区别？" class="headerlink" title="8.display:none与visibility：hidden的区别？"></a>8.display:none与visibility：hidden的区别？</h2><p>display：none 不显示对应的元素，在文档布局中不再分配空间（回流+重绘）<br>visibility：hidden 隐藏对应元素，在文档布局中仍保留原来的空间（重绘）</p><h2 id="9-position跟display、overflow、float这些特性相互叠加后会怎么样？"><a href="#9-position跟display、overflow、float这些特性相互叠加后会怎么样？" class="headerlink" title="9.position跟display、overflow、float这些特性相互叠加后会怎么样？"></a>9.position跟display、overflow、float这些特性相互叠加后会怎么样？</h2><p>display属性规定元素应该生成的框的类型；position属性规定元素的定位类型；float属性是一种布局方式，定义元素在哪个方向浮动。<br>类似于优先级机制：position：absolute/fixed优先级最高，有他们在时，float不起作用，display值需要调整。float 或者absolute定位的元素，只能是块元素或表格。</p><blockquote><p>转载文章时请注明本文的出处 || <a href="http://www.blog.54whg.cn" target="_blank" rel="noopener">咕噜先森的博客</a> 作者-&gt;@王华港</p></blockquote><script>var _hmt = _hmt || [];(function() {  var hm = document.createElement("script");  hm.src = "https://hm.baidu.com/hm.js?cb26b3220fad854a3119dd8d11ddc6eb";  var s = document.getElementsByTagName("script")[0];   s.parentNode.insertBefore(hm, s);})();</script>]]></content>
      
      <categories>
          
          <category> CSS3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS3 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【每日9个】CSS3重要知识点总结（一）</title>
      <link href="/2018/03/19/css301/"/>
      <content type="html"><![CDATA[<p><img src="/images/pic/06.jpg" alt=""></p><h2 id="1-什么是标准的CSS的盒子模型？与低版本IE的盒子模型有什么不同的？"><a href="#1-什么是标准的CSS的盒子模型？与低版本IE的盒子模型有什么不同的？" class="headerlink" title="1.什么是标准的CSS的盒子模型？与低版本IE的盒子模型有什么不同的？"></a>1.什么是标准的CSS的盒子模型？与低版本IE的盒子模型有什么不同的？</h2><p>标准盒子模型：宽度=内容的宽度（content）+ border + padding + margin<br>低版本IE盒子模型：宽度=内容宽度（content+border+padding）+ margin</p><h2 id="2-box-sizing属性？"><a href="#2-box-sizing属性？" class="headerlink" title="2.box-sizing属性？"></a>2.box-sizing属性？</h2><p>用来控制元素的盒子模型的解析模式，默认为content-box<br>context-box：W3C的标准盒子模型，设置元素的 height/width 属性指的是content部分的高/宽<br>border-box：IE传统盒子模型。设置元素的height/width属性指的是border + padding + content部分的高/宽</p><h2 id="3-CSS选择器有哪些？哪些属性可以继承？"><a href="#3-CSS选择器有哪些？哪些属性可以继承？" class="headerlink" title="3.CSS选择器有哪些？哪些属性可以继承？"></a>3.CSS选择器有哪些？哪些属性可以继承？</h2><p>CSS选择符：<br>id选择器(#myid)<br>类选择器(.myclassname)<br>标签选择器(div, h1, p)<br>相邻选择器(h1 + p)<br>子选择器（ul &gt; li）<br>后代选择器（li a）<br>通配符选择器（*）<br>属性选择器（a[rel=”external”]）<br>伪类选择器（a:hover, li:nth-child）<br>可继承的属性：font-size, font-family, color<br>不可继承的样式：border, padding, margin, width, height<br>优先级（就近原则）：!important &gt; [ id &gt; class &gt; tag ]<br>!important 比内联优先级高</p><h2 id="4-CSS优先级算法如何计算？"><a href="#4-CSS优先级算法如何计算？" class="headerlink" title="4.CSS优先级算法如何计算？"></a>4.CSS优先级算法如何计算？</h2><p>元素选择符： 1<br>class选择符： 10<br>id选择符：100<br>元素标签：1000<br>1.!important声明的样式优先级最高，如果冲突再进行计算。<br>2.如果优先级相同，则选择最后出现的样式。<br>3.继承得到的样式的优先级最低。</p><h2 id="5-CSS3新增伪类有那些"><a href="#5-CSS3新增伪类有那些" class="headerlink" title="5.CSS3新增伪类有那些?"></a>5.CSS3新增伪类有那些?</h2><p>p:first-of-type 选择属于其父元素的首个元素<br>p:last-of-type 选择属于其父元素的最后元素<br>p:only-of-type 选择属于其父元素唯一的元素<br>p:only-child 选择属于其父元素的唯一子元素<br>p:nth-child(2) 选择属于其父元素的第二个子元素<br>:enabled :disabled 表单控件的禁用状态。<br>:checked 单选框或复选框被选中。</p><h2 id="6-如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？"><a href="#6-如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？" class="headerlink" title="6.如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？"></a>6.如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">border: 1px solid red;</span><br><span class="line">margin: 0 auto;</span><br><span class="line">height: 50px;</span><br><span class="line">width: 80px;</span><br></pre></td></tr></table></figure><p>浮动元素的上下左右居中：<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line"><span class="attribute">float</span>: left;</span><br><span class="line"><span class="attribute">position</span>: absolute;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line"><span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line"><span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line"><span class="attribute">margin</span>: -<span class="number">50px</span> <span class="number">0</span> <span class="number">0</span> -<span class="number">100px</span>;</span><br></pre></td></tr></table></figure></p><p>绝对定位的左右居中：<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line"><span class="attribute">position</span>: absolute;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line"><span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">right</span>: <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p><p>除此之外还可以用flexbox。</p><h2 id="7-display有哪些值？说明他们的作用"><a href="#7-display有哪些值？说明他们的作用" class="headerlink" title="7.display有哪些值？说明他们的作用?"></a>7.display有哪些值？说明他们的作用?</h2><p>inline（默认）–内联<br>none–隐藏<br>block–块显示<br>table–表格显示<br>list-item–项目列表<br>inline-block</p><h2 id="8-position的值？"><a href="#8-position的值？" class="headerlink" title="8.position的值？"></a>8.position的值？</h2><p>static（默认）：按照正常文档流进行排列；<br>relative（相对定位）：不脱离文档流，参考自身静态位置通过 top, bottom, left, right 定位；<br>absolute(绝对定位)：参考距其最近一个不为static的父级元素通过top, bottom, left, right 定位；<br>fixed(固定定位)：所固定的参照对像是可视窗口。</p><h2 id="9-CSS3有哪些新特性？"><a href="#9-CSS3有哪些新特性？" class="headerlink" title="9.CSS3有哪些新特性？"></a>9.CSS3有哪些新特性？</h2><p>1.RGBA和透明度<br>2.background-image background-origin(content-box/padding-box/border-box) background-size background-repeat<br>3.word-wrap（对长的不可分割单词换行）word-wrap：break-word<br>4.文字阴影：text-shadow： 5px 5px 5px #FF0000;（水平阴影，垂直阴影，模糊距离，阴影颜色）<br>5.font-face属性：定义自己的字体<br>6.圆角（边框半径）：border-radius 属性用于创建圆角<br>7.边框图片：border-image: url(border.png) 30 30 round<br>8.盒阴影：box-shadow: 10px 10px 5px #888888<br>9.媒体查询：定义两套css，当浏览器的尺寸变化时会采用不同的属性</p><blockquote><p>转载文章时请注明本文的出处 || <a href="http://www.blog.54whg.cn" target="_blank" rel="noopener">咕噜先森的博客</a> 作者-&gt;@王华港</p></blockquote><script>var _hmt = _hmt || [];(function() {  var hm = document.createElement("script");  hm.src = "https://hm.baidu.com/hm.js?cb26b3220fad854a3119dd8d11ddc6eb";  var s = document.getElementsByTagName("script")[0];   s.parentNode.insertBefore(hm, s);})();</script>]]></content>
      
      <categories>
          
          <category> CSS3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS3 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>What is closure？怎样理解闭包</title>
      <link href="/2018/03/19/closure/"/>
      <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>闭包这个东西在JavaScript中是一个很强大的东西，但是在初学的阶段总是被其概念绕晕，搞不清楚到底什么是闭包，感觉很高深。作者在刚学的时候也有一点懵圈，多看几次就会有自己的理解。任何东西都没有唯一的标准，只要适合自己，自己能够理解的就是正确的。由于作者水平有限，将自己的一些见解拿出来，希望大家能够提出宝贵的意见。</p><h2 id="2-作用域"><a href="#2-作用域" class="headerlink" title="2.作用域"></a>2.作用域</h2><p>在正式讲闭包之前，我们来简单的说一说作用域这个东西。这个很有助于大家理解后面的闭包。<br>什么是域？简单的说就是一个被圈起来的地方，也就是变量能够访问的一个范围。<br>众所周知，变量的作用域分为全局变量和局部变量。定义在函数外部的称为全局变量，在函数内部的称为局部变量。这里顺带提一下，变量提升这个玩意儿，也就是和“先声明后使用差不多的道理”，后面我将会举一个例子来说明。<br>举个例子，全局变量和局部变量:<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="string">'wang'</span>;</span><br><span class="line">function <span class="function"><span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b=<span class="string">'huagang'</span>;</span><br><span class="line">    console.log(<span class="string">'这是在函数内部的输出'</span>);</span><br><span class="line">    console.log(a);</span><br><span class="line">    console.log(b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">fun</span><span class="params">()</span></span>;<span class="comment">//调用函数</span></span><br><span class="line"></span><br><span class="line">console.log(<span class="string">"这是在函数外部的输出"</span>);</span><br><span class="line">console.log(a);</span><br><span class="line">console.log(b);</span><br></pre></td></tr></table></figure></p><p>运行结果:<br><img src="/images/closure/clo1.png" alt="运行结果"><br>最后一个输出b的时候抛出了一个未定义异常，由此可见，全局变量（a）在函数内部和外部都是能访问的，但是局部变量不是这样的，在函数作用域外是不能访问到函数内部的变量（b）的。这里顺带讲一下【变量提升】吧，简单的举一个例子。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line">a=<span class="string">'wang'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br></pre></td></tr></table></figure></p><p><img src="/images/closure/clo2.png" alt="运行结果"><br>根据输出情况可以看出，第一次输出a并没有报异常，而是undefined。第二次便能输出a的值。这就是变量提升的特点，在变量还没赋值前就拿来使用了。</p><h2 id="3-嵌套函数的作用域"><a href="#3-嵌套函数的作用域" class="headerlink" title="3.嵌套函数的作用域"></a>3.嵌套函数的作用域</h2><p>嵌套函数，顾名思义就是在函数的内部再写一个或多个函数。下面举一个例子来讲解一下嵌套函数的作用域。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funA</span>(<span class="params">c</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a=<span class="string">'wang'</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">funB</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> b=<span class="string">'gang'</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"在函数B中的输出："</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(a);</span><br><span class="line">        <span class="built_in">console</span>.log(c);</span><br><span class="line">        <span class="built_in">console</span>.log(b);</span><br><span class="line">    &#125;</span><br><span class="line">    funB();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"在函数A中的输出："</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="built_in">console</span>.log(c);</span><br><span class="line">    <span class="built_in">console</span>.log(b);</span><br><span class="line">&#125;</span><br><span class="line">funA(<span class="string">'hua'</span>);<span class="comment">//调用函数A并传参</span></span><br></pre></td></tr></table></figure></p><p><img src="/images/closure/clo3.png" alt="运行结果"><br>函数B就是嵌套在函数A中的嵌套函数，它可以继承函数A的变量和参数，但是B中的变量A是不能访问的，就好像B给自己的门上了锁，“只进不出”，我可以拿你的东西，但是你不可以拿我的东西。B这样就形成了一个自己独有的封闭空间，这就是一个闭包。<br>从不同的角度来看：从语法结构上看，函数A包含函数B；从作用域来看，函数B包含函数A，也就是说B能访问的空间比A大。<br>因此可以想象得出，假如B函数中还有一个嵌套函数X，那么这个X函数也是一个闭包，作用域包含B和A。这样下去就形成了一个作用域链。</p><h2 id="4-闭包"><a href="#4-闭包" class="headerlink" title="4.闭包"></a>4.闭包</h2><p>相信通过上面的讲解，大家已经懂得了什么是闭包，现在再讲讲一些关于闭包的特点或者特性吧。</p><h4 id="保存变量"><a href="#保存变量" class="headerlink" title="保存变量"></a>保存变量</h4><p>什么是保存变量？加入B这个闭包需要两个变量才能运行，但是刚开始只传了一个参数进去，所以这时候闭包就会把这个变量的值进行保存，等待第二个变量传入，而不是丢弃这个变量的值。下面举一个例子进行说明吧。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funA</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">funB</span>(<span class="params">b</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> funB;<span class="comment">//调用函数B的引用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x = funA(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> sum = x(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sum);<span class="comment">//输出结果 5</span></span><br></pre></td></tr></table></figure></p><p><img src="/images/closure/clo4.png" alt="运行结果"><br>当函数A传进参数a=2时，这时闭包B就将a进行保存，等到再传b=3时再进行计算。这就是闭包的保存变量。</p><h2 id="5-为什么要使用闭包"><a href="#5-为什么要使用闭包" class="headerlink" title="5.为什么要使用闭包"></a>5.为什么要使用闭包</h2><p>使用闭包的最大的好处——避免变量的污染。也就是说你在闭包中声明的变量不会影响在其他地方也使用这个变量名称，因为闭包将这个变量锁在自己的门里面保护起来了，外部是无法修改的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funA</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">funB</span>(<span class="params">b</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> a = <span class="string">'wang'</span>;<span class="comment">//内部变量 c</span></span><br><span class="line">        <span class="keyword">return</span> a+b ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> funB;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="string">'hua'</span>;<span class="comment">//外部变量x，是不能改变闭包B中的变量a的</span></span><br><span class="line"><span class="keyword">var</span> sum = funA()(a);</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="built_in">console</span>.log(sum);</span><br></pre></td></tr></table></figure></p><p><img src="/images/closure/clo5.png" alt="运行结果"><br>可以看出，外部变量是不能修改闭包中的变量a的值的，从而保护了a的值，使其不会受到污染。</p><p>闭包的分享就讲到这里啦，我相信大家能够对闭包能够有一定的了解。当然，由于作者水平有限，这只是个人的见解，有误的地方还希望多多包涵，或者留言告知我。</p><blockquote><p>转载文章时请注明本文的出处 || <a href="http://www.blog.54whg.cn" target="_blank" rel="noopener">咕噜先森的博客</a> 作者-&gt;@王华港</p></blockquote><script>var _hmt = _hmt || [];(function() {  var hm = document.createElement("script");  hm.src = "https://hm.baidu.com/hm.js?cb26b3220fad854a3119dd8d11ddc6eb";  var s = document.getElementsByTagName("script")[0];   s.parentNode.insertBefore(hm, s);})();</script>]]></content>
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>js如何实现倒计时的原理分析及实现</title>
      <link href="/2018/03/18/countDown/"/>
      <content type="html"><![CDATA[<h3 id="js倒计时原理"><a href="#js倒计时原理" class="headerlink" title="js倒计时原理"></a>js倒计时原理</h3><p>倒计时=预计时间点-当前时间点<br>最后将倒计时转换成我们所需要的格式即可（eg：<em>时</em>分*秒）<br>再使用setInterval(function, 1000);每一秒执行一次，动态刷新一次就好。</p><h3 id="js代码实现"><a href="#js代码实现" class="headerlink" title="js代码实现"></a>js代码实现</h3><figure class="highlight plain"><figcaption><span>timer </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">countDown();</span><br><span class="line">timer = setInterval(countDown, 1000);</span><br><span class="line"></span><br><span class="line">// 倒计时计算函数</span><br><span class="line">function countDown()&#123;</span><br><span class="line">    var nowTime = new Date();     // 获取当前日期</span><br><span class="line">    var endTime = new Date(2018,4,20,20,35,0);   //预计时间，注意month需要减1  </span><br><span class="line">    var t = Math.floor((endTime - nowTime)/1000);     // 计算差值（单位：秒）</span><br><span class="line">    var Day = Math.floor(Math.floor(t/86400));     // 天（86400 = 24*3600）</span><br><span class="line">    var Hour = Math.floor(t%86400/3600);   // 时</span><br><span class="line">    var Min = Math.floor((t%3600)/60);    // 分</span><br><span class="line">    var Sec = t%60;     // 秒</span><br><span class="line">    if ( t==0 )&#123;</span><br><span class="line">        clearInterval(timer);</span><br><span class="line">        document.getElementById(&quot;showDiv&quot;).innerHTML = &quot;倒计时结束！&quot;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        document.getElementById(&quot;showDiv&quot;) = &quot;倒计时还有：&quot; + add(Day) + &quot;天&quot; + add(Hour) + &quot;:&quot; + add(Min) + &quot;:&quot; + add(Sec);</span><br><span class="line">          &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function add(iNum)&#123;</span><br><span class="line">    return iNum&lt;10 ? &quot;0&quot;+iNum : iNum; //若时间是个位数，则添加一个0在前面</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>转载文章时请注明本文的出处 || <a href="http://www.blog.54whg.cn" target="_blank" rel="noopener">咕噜先森的博客</a> 作者-&gt;@王华港</p></blockquote><script>var _hmt = _hmt || [];(function() {  var hm = document.createElement("script");  hm.src = "https://hm.baidu.com/hm.js?cb26b3220fad854a3119dd8d11ddc6eb";  var s = document.getElementsByTagName("script")[0];   s.parentNode.insertBefore(hm, s);})();</script>]]></content>
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>base64编码的原理及分析</title>
      <link href="/2018/03/18/base64/"/>
      <content type="html"><![CDATA[<h2 id="1-为什么要使用base64编码"><a href="#1-为什么要使用base64编码" class="headerlink" title="1.为什么要使用base64编码"></a>1.为什么要使用base64编码</h2><p>因为有些网络传送渠道并不支持所有的字节，例如传统的邮件只支持可见字符的传送，像ASCII码的控制字符就不能通过邮件传送。这样就受到了很大的限制，比如图片二进制流的每个字节不可能全部是可见字符，所以就传送不了。最好的方法就是在不改变传统协议的情况下，开辟一种新的方案来支持二进制文件的传送。把不可见字符用可见字符来表示。而Base64就是一种基于64个可见字符来表示二进制数据的表示方法。</p><p><strong>提示：不可见字符其实并不是不显示，只是这些字符在屏幕上显示不出来，比如：换行符、回车、退格等字符。</strong></p><h2 id="2-base64编码的原理"><a href="#2-base64编码的原理" class="headerlink" title="2.base64编码的原理"></a>2.base64编码的原理</h2><p>Base64可以将ASCII字符串或者是二进制编码成只包含A—Z，a—z，0—9，+，/ 这64个字符（ 26个大写字母，26个小写字母，10个数字，1个+，一个 / 刚好64个字符）。</p><p>Base64的编码规则是将3个8位字节(3×8=24位)编码成4个6位的字节(4×6=24位)，之后在每个6位字节前面，补充两个0，形成4个8位字节的形式，那么取值范围就变成了0~63。又因为2的6次方等于64，所以每6个位组成一个单元。</p><p>下图为base64的字符转换表：<br><img src="/images/base64.png" alt="base64转换表"></p><p>说太多了感觉复杂，直接上例子：<br><img src="/images/base64_ex.png" alt="base64举例"></p><blockquote><p>该图片转载自 <a href="https://www.jianshu.com/p/dd8bffc91c3d" target="_blank" rel="noopener">https://www.jianshu.com/p/dd8bffc91c3d</a></p></blockquote><p><strong>所以，abc的base64的编码为YWJj；ab的base64编码为YWI=；a的base64编码为YQ==。</strong>     </p><p>若末尾的为0，则对应的是A，但通常都用=来表示。因为 = 字符并不在Base64编码索引表中，其意义在于结束符号，在Base64解码时遇到 = 时即可知道一个Base64编码字符串结束。<br>解码是对编码的逆向操作，但注意一点：对于最后的两个 = 字符，转换成两个A 字符，再转成对应的两个6比特二进制0值，接着转成原始字符之前，需要将最后的两个6比特二进制0值丢弃，因为它们实际上不携带有效信息。</p><p>在实际开发过程中，base64一般用于字符和图片的编码，最后，推荐一个在线base64的编码与解码网址：<a href="http://base64.xpcha.com/" target="_blank" rel="noopener">base64编码</a></p><blockquote><p>转载文章时请注明本文的出处 || <a href="http://www.blog.54whg.cn" target="_blank" rel="noopener">咕噜先森的博客</a> 作者-&gt;@王华港</p></blockquote><script>var _hmt = _hmt || [];(function() {  var hm = document.createElement("script");  hm.src = "https://hm.baidu.com/hm.js?cb26b3220fad854a3119dd8d11ddc6eb";  var s = document.getElementsByTagName("script")[0];   s.parentNode.insertBefore(hm, s);})();</script>]]></content>
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python实战数据结构——列表/元组</title>
      <link href="/2018/03/18/singCount/"/>
      <content type="html"><![CDATA[<h3 id="Python实战题目"><a href="#Python实战题目" class="headerlink" title="Python实战题目"></a>Python实战题目</h3><p>比赛评分：校园歌手大奖赛中，每个歌手的得分由10名评委和观众决定，最终得分的规则是去掉10名评委所打分数的一个最高分和一个最低分，再加上所有观众评委分数后的平均值。请编写程序输入某个选手的10个评委分数和观众评分，计算其最后得分。</p><h3 id="实战分析"><a href="#实战分析" class="headerlink" title="实战分析"></a>实战分析</h3><p>1.先接受用户输入的所有数据，存在列表中，此时的数据为字符串，应当转换成float，因为求平均分可能会出现小数。</p><p>2.利用Python的内置函数sort()进行排序，这里不用管是升序还是降序。</p><p>3.利用pop函数去掉第一个和最后一个数，即达到了去掉最高分和最低分的要求。</p><p>4.利用for  in  遍历出剩下的所有数，并进行求和sum。</p><p>5.将sum与观众的分相加除以总人数便可算出最终得分。</p><h3 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sum=0;</span><br><span class="line">inputScore=input(<span class="string">"请输入10个分数，以,隔开:"</span>);</span><br><span class="line">aScore=input(<span class="string">"请输入观众评分："</span>)</span><br><span class="line">splitScore=inputScore.split(',');</span><br><span class="line">intScore = list(map(float, splitScore))<span class="comment"># 把字符串转化成float</span></span><br><span class="line">intScore.sort()</span><br><span class="line">intScore.pop();<span class="comment">#去除末尾的数</span></span><br><span class="line">intScore.pop(0);<span class="comment">#去除最开始的数</span></span><br><span class="line">for x in intScore:</span><br><span class="line">    sum+=x;</span><br><span class="line">avg=(sum+float(aScore))/(len(intScore)+1);</span><br><span class="line">print(<span class="string">"该选手最终得分：%.2f"</span>%avg)</span><br></pre></td></tr></table></figure><blockquote><p>转载文章时请注明本文的出处 || <a href="http://www.blog.54whg.cn" target="_blank" rel="noopener">咕噜先森的博客</a> 作者-&gt;@王华港</p></blockquote><script>var _hmt = _hmt || [];(function() {  var hm = document.createElement("script");  hm.src = "https://hm.baidu.com/hm.js?cb26b3220fad854a3119dd8d11ddc6eb";  var s = document.getElementsByTagName("script")[0];   s.parentNode.insertBefore(hm, s);})();</script>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Git 常用的基本命令</title>
      <link href="/2018/03/17/gitLearn/"/>
      <content type="html"><![CDATA[<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>git config –global user.name “Your Name”<br>git config –global user.email “<a href="mailto:email@example.com" target="_blank" rel="noopener">email@example.com</a>“</p><hr><h2 id="本地仓库—-gt-远程仓库的基本步骤"><a href="#本地仓库—-gt-远程仓库的基本步骤" class="headerlink" title="本地仓库—&gt;远程仓库的基本步骤"></a>本地仓库—&gt;远程仓库的基本步骤</h2><p>git init 新建一个仓库<br>git status 查看仓库当前的状态<br>git add <file> 可反复多次使用，添加多个文件；<br>git add ./–all  添加当前文件夹的所有文件<br>git commit -m “修改内容” 提交到本地仓库<br>git remote 查看当前配置有哪些远程仓库<br>git remote add origin <a href="https://github.com/WangHuagang/git-demo.git" target="_blank" rel="noopener">https://github.com/WangHuagang/git-demo.git</a> 将文件添加到指定的GitHub上的仓库<br>git push -u origin master(分支) 将文件推送到远程仓库上<br>git pull origin master(将远程仓库的东西“拉”回来)</file></p><hr><h2 id="其余常用的命令"><a href="#其余常用的命令" class="headerlink" title="其余常用的命令"></a>其余常用的命令</h2><p>git status -s  查看变更日志<br>git log   可以查看提交日志<br>git reset –hard (6位版本号) 回归到指定版本<br>git diff  可以用于对比当前状态和版本库中状态的变化<br>git branch   查看分支<br>git branch （分支名）   创建一个新的分支<br>git checkout （分支名）  切换分支<br>git clone <a href="https://github.com/WangHuagang/git-demo.git" target="_blank" rel="noopener">https://github.com/WangHuagang/git-demo.git</a> .(.表示当前目录) 将远程仓库整个项目克隆到当前目录<br>git merge <name>  合并某分支到当前分支<br>git branch -d <name>  删除分支</name></name></p><hr><h2 id="将本地文件放在github上显示"><a href="#将本地文件放在github上显示" class="headerlink" title="将本地文件放在github上显示"></a>将本地文件放在github上显示</h2><p>1.创建gh-pages分支，利用gh-pages分支上传到远程仓库<br>2.配置文件CNAME：绑定域名</p><hr><h2 id="git搭建自己的博客"><a href="#git搭建自己的博客" class="headerlink" title="git搭建自己的博客"></a>git搭建自己的博客</h2><p>1.npm install hexo-cli -g   安装hexo<br>2.hexo init blog   新建一个博客仓库<br>3.cd blog   到博客文件夹下<br>4.npm install   安装需要的包<br>5.hexo serve  开启博客</p><p><strong><em>hexo搭建博客更多的配置将会在后面继续更新</em></strong></p><blockquote><p>转载文章时请注明本文的出处 || <a href="http://www.blog.54whg.cn" target="_blank" rel="noopener">咕噜先森的博客</a> 作者-&gt;@王华港</p></blockquote><script>var _hmt = _hmt || [];(function() {  var hm = document.createElement("script");  hm.src = "https://hm.baidu.com/hm.js?cb26b3220fad854a3119dd8d11ddc6eb";  var s = document.getElementsByTagName("script")[0];   s.parentNode.insertBefore(hm, s);})();</script>]]></content>
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>9步教你搭建个人博客(Hexo+Github)</title>
      <link href="/2018/03/17/hexoBlog/"/>
      <content type="html"><![CDATA[<h4 id="1-下载并安装node-js和npm（新版本的node已经自带npm，不用单独下载）"><a href="#1-下载并安装node-js和npm（新版本的node已经自带npm，不用单独下载）" class="headerlink" title="1.下载并安装node.js和npm（新版本的node已经自带npm，不用单独下载）"></a>1.下载并安装node.js和npm（新版本的node已经自带npm，不用单独下载）</h4><p><img src="/images/hexo_github/hexo_1.png" alt="博主安装好的环境"></p><h4 id="2-安装git的环境，傻瓜式的安装方法，默认安装即可"><a href="#2-安装git的环境，傻瓜式的安装方法，默认安装即可" class="headerlink" title="2.安装git的环境，傻瓜式的安装方法，默认安装即可"></a>2.安装git的环境，傻瓜式的安装方法，默认安装即可</h4><p><img src="/images/hexo_github/hexo_2.png" alt="安装好后的情况"></p><h4 id="3-注册github账号，并创建一个新的仓库，仓库的格式一定要按照这种格式来：name-github-io，其他的默认就好"><a href="#3-注册github账号，并创建一个新的仓库，仓库的格式一定要按照这种格式来：name-github-io，其他的默认就好" class="headerlink" title="3.注册github账号，并创建一个新的仓库，仓库的格式一定要按照这种格式来：name.github.io，其他的默认就好"></a>3.注册github账号，并创建一个新的仓库，仓库的格式一定要按照这种格式来：<strong><em>name.github.io</em></strong>，其他的默认就好</h4><p><img src="/images/hexo_github/hexo_3.png" alt=""></p><h4 id="4-安装hexo，在电脑某个合适的地方新建一个文件夹（eg：blog），然后命令行进入到该文件夹，按照以下步骤进行安装"><a href="#4-安装hexo，在电脑某个合适的地方新建一个文件夹（eg：blog），然后命令行进入到该文件夹，按照以下步骤进行安装" class="headerlink" title="4.安装hexo，在电脑某个合适的地方新建一个文件夹（eg：blog），然后命令行进入到该文件夹，按照以下步骤进行安装"></a>4.安装hexo，在电脑某个合适的地方新建一个文件夹（eg：blog），然后命令行进入到该文件夹，按照以下步骤进行安装</h4><p>-安装hexo<br><code>npm install hexo -g</code><br>-检查是否安装成功<br><code>hexo -v</code><br>-初始化该文件夹<br><code>hexo init</code><br>-安装所需要的组件<br><code>hexo install</code><br>-体验一下hexo<br><code>hexo g</code><br>-开启服务器，正式访问网址体验hexo，输入localhost:4000访问<br><code>hexo s</code><br>若出现下图，启动服务器成功<br><img src="/images/hexo_github/4.png" alt=""><br>若不能成功，可能是端口冲突，请输入以下命令进行切换端口<br><code>hexo server -p</code><br>当看见出现以下页面，表示博客基本框架搭建成功<br><img src="/images/hexo_github/5.png" alt=""></p><h4 id="5-将hexo与GitHub联系起来，配置name和email（ps：如果已经配置过的可以忽略），在blog文件夹中右键打开Git-Bash进行配置"><a href="#5-将hexo与GitHub联系起来，配置name和email（ps：如果已经配置过的可以忽略），在blog文件夹中右键打开Git-Bash进行配置" class="headerlink" title="5.将hexo与GitHub联系起来，配置name和email（ps：如果已经配置过的可以忽略），在blog文件夹中右键打开Git Bash进行配置"></a>5.将hexo与GitHub联系起来，配置name和email（ps：如果已经配置过的可以忽略），在blog文件夹中右键打开Git Bash进行配置</h4><p><code>git config --global user.name &#39;your github name&#39;</code><br><code>git config --global user.email &#39;your github email&#39;</code></p><h5 id="5-1输入ssh-keygen-t-rsa-C-“cdu-whg-foxmail-com”-连续按三个回车键，生成秘钥，得到了两个文件：id-rsa和id-rsa-pub（默认存储路径是：C-Users-Administrator-ssh）。"><a href="#5-1输入ssh-keygen-t-rsa-C-“cdu-whg-foxmail-com”-连续按三个回车键，生成秘钥，得到了两个文件：id-rsa和id-rsa-pub（默认存储路径是：C-Users-Administrator-ssh）。" class="headerlink" title="5.1输入ssh-keygen -t rsa -C “cdu.whg@foxmail.com” ,连续按三个回车键，生成秘钥，得到了两个文件：id_rsa和id_rsa.pub（默认存储路径是：C:\Users\Administrator.ssh）。"></a>5.1输入ssh-keygen -t rsa -C “<a href="mailto:cdu.whg@foxmail.com" target="_blank" rel="noopener">cdu.whg@foxmail.com</a>” ,连续按三个回车键，生成秘钥，得到了两个文件：id_rsa和id_rsa.pub（默认存储路径是：C:\Users\Administrator.ssh）。</h5><h5 id="5-2-输入eval-“-ssh-agent-s-”，添加密钥到ssh-agent。"><a href="#5-2-输入eval-“-ssh-agent-s-”，添加密钥到ssh-agent。" class="headerlink" title="5.2 输入eval “$(ssh-agent -s)”，添加密钥到ssh-agent。"></a>5.2 输入eval “$(ssh-agent -s)”，添加密钥到ssh-agent。</h5><h5 id="5-3-再输入ssh-add-ssh-id-rsa，添加生成的SSH-key到ssh-agent。"><a href="#5-3-再输入ssh-add-ssh-id-rsa，添加生成的SSH-key到ssh-agent。" class="headerlink" title="5.3 再输入ssh-add ~/.ssh/id_rsa，添加生成的SSH key到ssh-agent。"></a>5.3 再输入ssh-add ~/.ssh/id_rsa，添加生成的SSH key到ssh-agent。</h5><h5 id="5-4-登陆GitHub，点击头像下拉菜单中的setting，添加ssh"><a href="#5-4-登陆GitHub，点击头像下拉菜单中的setting，添加ssh" class="headerlink" title="5.4 登陆GitHub，点击头像下拉菜单中的setting，添加ssh"></a>5.4 登陆GitHub，点击头像下拉菜单中的setting，添加ssh</h5><p><img src="/images/hexo_github/6.png" alt=""></p><h5 id="5-5-新建一个new-SSH-Key-，输入名称和秘钥（id-rsa-pub文件中的秘钥）即可"><a href="#5-5-新建一个new-SSH-Key-，输入名称和秘钥（id-rsa-pub文件中的秘钥）即可" class="headerlink" title="5.5 新建一个new SSH Key ，输入名称和秘钥（id_rsa.pub文件中的秘钥）即可"></a>5.5 新建一个new SSH Key ，输入名称和秘钥（id_rsa.pub文件中的秘钥）即可</h5><p><img src="/images/hexo_github/7.png" alt=""></p><h4 id="6-配置，找到根文件夹下的-config-yml文件，按照下图进行修改配置"><a href="#6-配置，找到根文件夹下的-config-yml文件，按照下图进行修改配置" class="headerlink" title="6.配置，找到根文件夹下的_config.yml文件，按照下图进行修改配置"></a>6.配置，找到根文件夹下的_config.yml文件，按照下图进行修改配置</h4><p><img src="/images/hexo_github/8.png" alt=""><br><img src="/images/hexo_github/9.png" alt=""></p><h4 id="7-开启写博客之旅，输入一下命令，建立第一篇blog"><a href="#7-开启写博客之旅，输入一下命令，建立第一篇blog" class="headerlink" title="7.开启写博客之旅，输入一下命令，建立第一篇blog"></a>7.开启写博客之旅，输入一下命令，建立第一篇blog</h4><p><code>hexo new post &#39;blogName&#39;</code></p><h5 id="在source-posts目录下可看见增加了一个hello-md文件，编辑该文件内容，便可发布博客了"><a href="#在source-posts目录下可看见增加了一个hello-md文件，编辑该文件内容，便可发布博客了" class="headerlink" title="在source/_posts目录下可看见增加了一个hello.md文件，编辑该文件内容，便可发布博客了"></a>在source/_posts目录下可看见增加了一个hello.md文件，编辑该文件内容，便可发布博客了</h5><p><img src="/images/hexo_github/10.png" alt=""></p><h4 id="8-在生成以及部署文章之前，需要安装一个扩展：npm-install-hexo-deployer-git-save"><a href="#8-在生成以及部署文章之前，需要安装一个扩展：npm-install-hexo-deployer-git-save" class="headerlink" title="8.在生成以及部署文章之前，需要安装一个扩展：npm install hexo-deployer-git --save"></a>8.在生成以及部署文章之前，需要安装一个扩展：<code>npm install hexo-deployer-git --save</code></h4><h4 id="9-安装完后便可以部署了，使用hexo-d-g进行部署"><a href="#9-安装完后便可以部署了，使用hexo-d-g进行部署" class="headerlink" title="9.安装完后便可以部署了，使用hexo d -g进行部署"></a>9.安装完后便可以部署了，使用<code>hexo d -g</code>进行部署</h4><p><img src="/images/hexo_github/11.png" alt=""></p><h5 id="部署成功后访问你的地址：http-用户名-github-io。那么就能看到生成发布的文章了。"><a href="#部署成功后访问你的地址：http-用户名-github-io。那么就能看到生成发布的文章了。" class="headerlink" title="部署成功后访问你的地址：http://用户名.github.io。那么就能看到生成发布的文章了。"></a>部署成功后访问你的地址：http://用户名.github.io。那么就能看到生成发布的文章了。</h5><p><img src="/images/hexo_github/12.png" alt=""></p><h4 id="OK，使用hexo-GitHub搭建基本的个人博客就完成了，后续会推出【提升版】，对个人博客进行更精致的设置以及绑定自己的域名。"><a href="#OK，使用hexo-GitHub搭建基本的个人博客就完成了，后续会推出【提升版】，对个人博客进行更精致的设置以及绑定自己的域名。" class="headerlink" title="OK，使用hexo+GitHub搭建基本的个人博客就完成了，后续会推出【提升版】，对个人博客进行更精致的设置以及绑定自己的域名。"></a>OK，使用hexo+GitHub搭建基本的个人博客就完成了，后续会推出【提升版】，对个人博客进行更精致的设置以及绑定自己的域名。</h4><p><code>console.log(&quot;敬请关注!&quot;)</code></p><blockquote><p>转载文章时请注明本文的出处 || <a href="http://www.blog.54whg.cn" target="_blank" rel="noopener">咕噜先森的博客</a> 作者-&gt;@王华港</p></blockquote><script>var _hmt = _hmt || [];(function() {  var hm = document.createElement("script");  hm.src = "https://hm.baidu.com/hm.js?cb26b3220fad854a3119dd8d11ddc6eb";  var s = document.getElementsByTagName("script")[0];   s.parentNode.insertBefore(hm, s);})();</script>]]></content>
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git学习 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
